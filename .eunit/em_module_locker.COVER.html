<html>
<head><title>.eunit/em_module_locker.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /home/sven/dev/erlymock/.eunit/em_module_locker.erl by COVER 2012-12-16 at 19:29:48

****************************************************************************

        |  %%%=============================================================================
        |  %%%
        |  %%% @author Sven Heyll &lt;sven.heyll@lindenbaum.eu&gt;
        |  %%% @copyright (C) 2011, Sven Heyll
        |  %%%
        |  %%% @doc
        |  %%% Internal server that provides a locking mechanism between em processes so that
        |  %%% no two mock processes mock the same modules.
        |  %%% A mock process locks some modules and as soon as the mock process dies, its
        |  %%% modules will automatically be unlocked.
        |  %%% @end
        |  %%%=============================================================================
        |  
        |  -module(em_module_locker).
        |  
        |  -behaviour(gen_server).
        |  
        |  %% API
        |  -export([lock/2]).
        |  
        |  %% gen_server callbacks
        |  -export([init/1,
        |           handle_call/3,
        |           handle_cast/2,
        |           handle_info/2,
        |           terminate/2,
        |           code_change/3]).
        |  
        |  -define(SERVER, ?MODULE).
        |  
        |  -record(state,
        |          {locked_modules = [] :: [module()],
        |           timers         = dict:new(),
        |           locking_mocks  = [] :: [{pid(), [module()], term()}],
        |           waiting_mocks  = [] :: [{pid(), [module()], term()}]}).
        |  
        |  -type state() :: #state{}.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% The maximum amount of time, that a process may lock modules before being
        |  %% brutally killed.
        |  %%------------------------------------------------------------------------------
        |  -define(MAX_LOCK_TIME, 4400).
        |  
        |  %%%=============================================================================
        |  %%% API
        |  %%%=============================================================================
        |  
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Blocks until the modules in the list can be mocked.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec lock(pid(), [module()]) -&gt;
        |                    ok.
        |  lock(MockPid, Mods) -&gt;
    28..|      case whereis(?MODULE) of
     2..|          undefined -&gt; gen_server:start({local, ?SERVER}, ?MODULE, [], []);
        |          _ -&gt;
    26..|              ok
        |      end,
    28..|      gen_server:call(?MODULE, {lock, MockPid, Mods}, infinity).
        |  
        |  %%%=============================================================================
        |  %%% gen_server Callbacks
        |  %%%=============================================================================
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec init(Args :: []) -&gt; {ok, state()}.
        |  init([]) -&gt;
     2..|      process_flag(sensitive, true),
     2..|      erlang:trace(self(), false, [all]),
     2..|      {ok, #state{}}.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec handle_call(Request :: term(), From :: term(), State :: state()) -&gt;
        |                           {reply, Reply :: term(), NewState :: state()} |
        |                           {stop, term(), term(), term()}.
        |  handle_call({lock, MockPid, Mods}, From,
        |              State = #state{}) -&gt;
    28..|      monitor(process, MockPid),
    28..|      NewState = State#state{waiting_mocks = [{MockPid, Mods, From} | State#state.waiting_mocks]},
    28..|      em_module_locker:handle_cast(perform_locking, NewState);
        |  
        |  handle_call(Request, _From, State) -&gt;
<font color=red>     0..|      {stop, {undefined, Request}, {unexpected_call, Request}, State}.</font>
        |  
        |  -spec handle_cast(Msg :: term(), State :: state()) -&gt;
        |                           {noreply, NewState :: state()} |
        |                           {stop, term(), term()}.
        |  handle_cast(perform_locking,
        |              State) -&gt;
    56..|      Mocks_To_Reply = [M || M = {_, Mods, _} &lt;- State#state.waiting_mocks,
    35..|                             (Mods -- (State#state.locked_modules)) == Mods],
    56..|      NewState = lists:foldr(fun(M = {MockPid, Mods, From}, StateAcc) -&gt;
    27..|                                     {ok, TRef} = timer:kill_after(?MAX_LOCK_TIME, MockPid),
    27..|                                     gen_server:reply(From, ok),
    27..|                                     StateAcc#state{
        |                                       timers =
        |                                           dict:store(MockPid, TRef, StateAcc#state.timers),
        |                                       locked_modules =
        |                                           StateAcc#state.locked_modules ++ Mods,
        |                                       waiting_mocks =
        |                                           StateAcc#state.waiting_mocks -- [M],
        |                                       locking_mocks =
        |                                           [M | StateAcc#state.locking_mocks]}
        |                             end,
        |                             State,
        |                             Mocks_To_Reply),
    56..|      {noreply, NewState};
        |  
        |  handle_cast(Request, State) -&gt;
<font color=red>     0..|      {stop, {unexpected_cast, Request}, State}.</font>
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec handle_info(Info :: term(), State :: state()) -&gt;
        |                           {noreply, State :: state()} | {stop, term(), term()}.
        |  handle_info({'DOWN', _Ref, process, Pid, _Reason},
        |              StateWithTimers = #state{timers = Timers}) -&gt;
    28..|      State = case dict:find(Pid, Timers) of
        |                  {ok, TRef} -&gt;
    26..|                      timer:cancel(TRef),
    26..|                      StateWithTimers#state{timers = dict:erase(Pid, Timers)};
        |                  _ -&gt;
     2..|                      StateWithTimers
        |      end,
    28..|      Mocks_To_Unlock = [M || M = {P, _, _} &lt;- State#state.locking_mocks,
    37..|                              P == Pid],
    28..|      Mods_To_Unlock = [Mod || {_, Mods, _} &lt;- Mocks_To_Unlock,
    27..|                              Mod &lt;- Mods],
        |  
    28..|      Mocks_Not_Waiting_Anymore = [M || M = {P, _, _} &lt;- State#state.waiting_mocks,
     7..|                                       P == Pid],
    28..|      gen_server:cast(?MODULE, perform_locking),
    28..|      {noreply,
        |       State#state{locked_modules = State#state.locked_modules -- Mods_To_Unlock,
        |                   locking_mocks = State#state.locking_mocks -- Mocks_To_Unlock,
        |                   waiting_mocks = State#state.waiting_mocks -- Mocks_Not_Waiting_Anymore}};
        |  
        |  handle_info(Info, State) -&gt;
<font color=red>     0..|      {stop, {unexpected_info, Info}, State}.</font>
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec terminate(Reason :: term(), State :: state()) -&gt; ok.
        |  terminate(_Reason, _State) -&gt;
<font color=red>     0..|      ok.</font>
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec code_change(OldVsn :: term(), State :: state(), Extra :: term()) -&gt;
        |                           {ok, NewState :: state()}.
        |  code_change(_OldVsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  %%%=============================================================================
        |  %%% Internal Functions
        |  %%%=============================================================================
</pre>
</body>
</html>
