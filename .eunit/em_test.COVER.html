<html>
<head><title>.eunit/em_test.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /home/sven/dev/erlymock/.eunit/em_test.erl by COVER 2012-12-16 at 19:29:47

****************************************************************************

        |  %%%-------------------------------------------------------------------
        |  %%% @author Sven Heyll &lt;sven.heyll@lindenbaum.eu&gt;
        |  %%% @copyright (C) 2011, Sven Heyll
        |  %%%-------------------------------------------------------------------
        |  -module(em_test).
        |  -include_lib("eunit/include/eunit.hrl").
        |  
        |  
        |  simple_strict_test() -&gt;
     1..|      M = em:new(),
     1..|      em:strict(M, some_mod, some_fun, [a,
        |                                           fun(B) -&gt;
     1..|                                                   B == b
        |                                           end]),
     1..|      em:strict(M, some_mod, some_fun_bad, [],
     1..|               {function, fun(_) -&gt; throw(xxx) end}),
     1..|      em:strict(M, some_mod, some_fun, [a,
        |                                           fun(B) -&gt;
     1..|                                                   B == c
        |                                           end]),
     1..|      em:strict(M, some_mod, some_other_fun, [a]),
     1..|      em:strict(M, some_other_mod, some_other_fun, [], {return, ok2}),
     1..|      em:replay(M),
     1..|      ok = some_mod:some_fun(a, b),
     1..|      ?assertEqual(xxx, (catch some_mod:some_fun_bad())),
     1..|      ok = some_mod:some_fun(a, c),
     1..|      ok = some_mod:some_other_fun(a),
     1..|      ok2 = some_other_mod:some_other_fun(),
     1..|      em:verify(M).
        |  
        |  invokation_timout_test() -&gt;
     1..|      Pid = spawn_link(fun() -&gt;
     1..|                               M = em:new(),
     1..|                               em:strict(M, some_mod, some_fun, [a]),
     1..|                               em:replay(M),
     1..|                               receive ok -&gt; ok end
        |                       end),
     1..|      process_flag(trap_exit, true),
     1..|      receive
        |          {'EXIT',
        |           Pid,
        |           Reason} -&gt;
     1..|              ?assertMatch({invokation_timeout,
        |                            {missing_invokations,
        |                             [{expectation,
        |                               _Ref,
        |                               some_mod,some_fun,[a],
        |                               {return,ok},
     1..|                               _Listeners}]}},
        |                           Reason)
        |      end.
        |  
        |  invalid_parameter_1_test() -&gt;
     1..|      M = em:new(),
     1..|      em:strict(M, some_mod, some_fun, [a,
        |                                           fun(B) -&gt;
<font color=red>     0..|                                                   B == b</font>
        |                                           end]),
     1..|      em:replay(M),
     1..|      process_flag(trap_exit, true),
     1..|      ?assertMatch({'EXIT',
        |                    {{case_clause,
        |                     {unexpected_function_parameter,
        |                      {error_in_parameter, 1}, {expected, a}, {actual, 666},
        |                      {invokation, some_mod, some_fun, [666, b], _}}},
     1..|                     _}},
        |                   catch some_mod:some_fun(666, b)).
        |  
        |  invalid_order_test() -&gt;
     1..|      M = em:new(),
     1..|      em:strict(M, some_mod, some_fun, [a,b]),
     1..|      em:strict(M, some_mod, some_fun, [a]),
     1..|      em:replay(M),
     1..|      process_flag(trap_exit, true),
     1..|      ?assertMatch({'EXIT',
        |                    {{case_clause,
        |                      {unexpected_invokation,
        |                       {actual,{invokation,some_mod,some_fun,[a], _}},
        |                       {expected,{expectation,_Ref, some_mod,some_fun,[a,b],
        |                                  {return,ok},
     1..|                                  _Listeners}}}}, _}},
        |                   catch some_mod:some_fun(a)).
        |  
        |  too_many_invokations_test() -&gt;
     1..|      M = em:new(),
     1..|      em:strict(M, some_mod, some_fun, [a,b]),
     1..|      em:replay(M),
     1..|      ok = some_mod:some_fun(a, b),
     1..|      process_flag(trap_exit, true),
     1..|      ?assertMatch({'EXIT', {{case_clause,{unexpected_invokation,
        |                                           {actual,
     1..|                                            {invokation,some_mod,some_fun,[a, b], _}}}}, _}},
        |                   catch some_mod:some_fun(a, b)).
        |  
        |  invokations_missing_test() -&gt;
     1..|      M = em:new(),
     1..|      em:strict(M, some_mod, some_fun, [a,b]),
     1..|      em:replay(M),
     1..|      process_flag(trap_exit, true),
     1..|      ?assertError({badmatch,
        |                    {invokations_missing,
     1..|                     [{expectation,_, some_mod,some_fun,[a,b],{return,ok}, _}]}},
     1..|                   em:verify(M)).
        |  
        |  invalid_parameter_2_test() -&gt;
     1..|      M = em:new(),
     1..|      em:strict(M, some_mod, some_fun, [a,
        |                                           fun(B) -&gt;
     1..|                                                   B == b
        |                                           end]),
     1..|      em:replay(M),
     1..|      process_flag(trap_exit, true),
     1..|      ?assertMatch({'EXIT', {{case_clause,
        |                              {unexpected_function_parameter,
        |                               {error_in_parameter, 2},
        |                               {expected, _},
        |                               {actual, 666},
     1..|                               {invokation, some_mod, some_fun, [a, 666], _}}}, _}},
        |                   catch(some_mod:some_fun(a, 666))).
        |  
        |  strict_and_stub_test() -&gt;
     1..|      M = em:new(),
     1..|      em:stub(M, some_modx, some_fun, [a, b, em:any()], {return, ok}),
     1..|      em:strict(M, some_mod, some_fun, [a, b], {function,
     1..|                                                   fun(Args) -&gt; Args end}),
     1..|      em:replay(M),
     1..|      ok = some_modx:some_fun(a, b, c),
     1..|      [a, b] = some_mod:some_fun(a, b),
     1..|      ok = some_modx:some_fun(a, b, c),
     1..|      ok = some_modx:some_fun(a, b, c),
     1..|      ok = some_modx:some_fun(a, b, random:uniform(123)),
     1..|      em:verify(M).
        |  
        |  stub_only_test() -&gt;
     1..|      M = em:new(),
     1..|      em:stub(M, some_modx, some_fun, [a, b, c], {return, ok123}),
     1..|      em:stub(M, some_mody, some_fun, [a, b, c]),
     1..|      em:stub(M, some_modz, some_fun, [a, b, c], {function, fun(_) -&gt; well end}),
     1..|      em:replay(M),
     1..|      well = some_modz:some_fun(a, b, c),
     1..|      ok123 = some_modx:some_fun(a, b, c),
     1..|      ok = some_mody:some_fun(a, b, c),
     1..|      ok123 = some_modx:some_fun(a, b, c),
     1..|      em:verify(M).
        |  
        |  fun_answer_test() -&gt;
     1..|      M = em:new(),
     1..|      em:stub(M, some_modx, some_fun, [a, b, c],
        |              {function, fun([a,b,c]) -&gt;
     1..|                                 answer
        |                         end}),
     1..|      em:replay(M),
     1..|      answer = some_modx:some_fun(a, b, c),
     1..|      em:verify(M).
        |  
        |  empty_stub_test() -&gt;
     1..|      M = em:new(),
     1..|      em:stub(M, some_modx, some_fun, [a, a, c], {return, ok}),
     1..|      em:replay(M),
     1..|      em:verify(M).
        |  
        |  empty_test() -&gt;
     1..|      M = em:new(),
     1..|      em:replay(M),
     1..|      em:verify(M).
        |  
        |  check_arguments_test() -&gt;
     1..|      M = em:new(),
     1..|      ?assertException(error, function_clause, em:stub(M,x,y,[],bad)),
     1..|      ?assertException(error, function_clause, em:strict(M,x,y,[],{function1, also_bad})),
     1..|      em:replay(M),
     1..|      em:verify(M).
        |  
        |  gen_fsm_unimplemented_stops_test() -&gt;
     1..|      ?assertEqual({stop, normal, state}, em:handle_info(x, y, state)),
     1..|      ?assertEqual({stop, normal, ok, state}, em:handle_sync_event(x, y, z, state)),
     1..|      ?assertEqual({stop, normal, state}, em:handle_event(x, y, state)),
     1..|      ?assertEqual({ok, state_name, state}, em:code_change(old_vsn, state_name, state, extra)).
        |  
        |  nothing_test() -&gt;
     1..|      {module, _} = code:ensure_loaded(mnesia),
     1..|      M = em:new(),
     1..|      em:nothing(M, mnesia),
     1..|      em:replay(M),
     1..|      ?assertMatch({'EXIT', {undef, _}}, catch mnesia:blub(some_arg)),
     1..|      ?assertMatch(ok, em:verify(M)).
        |  
        |  auto_lock_test() -&gt;
     1..|      process_flag(trap_exit, true),
     1..|      Target = self(),
     1..|      spawn(fun() -&gt;
     1..|                    M1 = em:new(),
     1..|                    em:strict(M1, mod1, test, [x]),
     1..|                    em:replay(M1),
     1..|                    receive after 1 -&gt; ok end,
     1..|                    mod1:test(x),
     1..|                    em:verify(M1),
     1..|                    Target ! m1
        |            end),
     1..|      spawn(fun() -&gt;
     1..|                    M2 = em:new(),
     1..|                    em:strict(M2, mod1, test, [y,z]),
     1..|                    em:replay(M2),
     1..|                    receive after 1 -&gt; ok end,
     1..|                    mod1:test(y,z),
     1..|                    em:verify(M2),
     1..|                    Target ! m2
        |            end),
     1..|      receive
        |          m1 -&gt;
     1..|              receive
        |                  m2 -&gt;
     1..|                      ok
        |              end
        |      end.
        |  
        |  explicit_lock_test() -&gt;
     1..|      process_flag(trap_exit, true),
     1..|      Target = self(),
     1..|      spawn(fun() -&gt;
     1..|                    M1 = em:new(),
     1..|                    em:strict(M1, mmod1, test, [x]),
     1..|                    em:replay(M1),
     1..|                    receive after 1 -&gt; ok end,
     1..|                    mmod1:test(x),
     1..|                    em:verify(M1),
     1..|                    Target ! mm1
        |            end),
     1..|      spawn(fun() -&gt;
     1..|                    M2 = em:new(),
     1..|                    em:lock(M2, [mmod1, mmod3]),
     1..|                    em:strict(M2, mmod2, test, [y,z]),
     1..|                    em:replay(M2),
     1..|                    receive after 1 -&gt; ok end,
     1..|                    mmod2:test(y,z),
     1..|                    em:verify(M2),
     1..|                    Target ! mm2
        |            end),
     1..|      receive
        |          mm1 -&gt;
     1..|              receive
        |                  mm2 -&gt;
     1..|                      ok
        |              end
        |      end.
        |  
        |  em_zelf_test() -&gt;
     1..|      M = em:new(),
     1..|      em:strict(M, mod, f, [em:zelf()]),
     1..|      em:replay(M),
     1..|      mod:f(self()),
     1..|      em:verify(M).
        |  
        |  await_expectations_noexpectations_test() -&gt;
     1..|      M = em:new(),
     1..|      Test = self(),
     1..|      em:strict(M, mod, f, [],
     1..|               {function, fun(_) -&gt; Test ! go_on end}),
     1..|      em:replay(M),
     1..|      mod:f(),
     1..|      receive go_on -&gt; ok end,
     1..|      em:await_expectations(M).
        |  
        |  await_expectations_test() -&gt;
     1..|      M = em:new(),
     1..|      Test = self(),
     1..|      em:strict(M, mod, f, [],
     1..|               {function, fun(_) -&gt; Test ! go_on end}),
     1..|      em:replay(M),
     1..|      spawn(fun() -&gt; receive after 200 -&gt; mod:f() end end),
     1..|      em:await_expectations(M).
        |  
        |  await_test() -&gt;
     1..|      M = em:new(),
     1..|      F1 = em:strict(M, mod, f1, [arg1, arg2], {return, ret}),
     1..|      F2 = em:strict(M, mod, f2, []),
     1..|      em:strict(M, mod, f3, []),
     1..|      em:replay(M),
     1..|      mod:f1(arg1, arg2),
     1..|      OtherPid = spawn(fun() -&gt; receive after 200 -&gt; mod:f2() end end),
        |      %% ... and block until it happens
     1..|      ?assertEqual({success, OtherPid, []},
     1..|                   em:await(M, F2)),
        |      %% in the invokation has already happened em:await shall return
        |      %% immediately with the historic invokation details...
     1..|      ?assertEqual({success, self(), [arg1, arg2]},
     1..|                   em:await(M, F1)),
     1..|      mod:f3(),
     1..|      ?assertEqual({error, invalid_handle}, em:await(M, xxx)),
     1..|      em:verify(M).
</pre>
</body>
</html>
