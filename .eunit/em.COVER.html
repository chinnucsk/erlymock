<html>
<head><title>.eunit/em.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /home/sven/dev/erlymock/.eunit/em.erl by COVER 2012-12-16 at 19:29:48

****************************************************************************

        |  %%%-----------------------------------------------------------------------------
        |  %%% @author Sven Heyll &lt;sven.heyll@lindenbaum.eu&gt;
        |  %%% @copyright (C) 2011, 2012 Sven Heyll
        |  %%% @doc
        |  %%% The module name 'em' stands for 'Erly Mock'.
        |  %%%
        |  %%% &lt;p&gt;This mocking library works similar to Easymock.&lt;/p&gt;
        |  %%%
        |  %%% &lt;p&gt;After a mock process is started by {@link new/0} it can be
        |  %%% programmed to expect function calls and to react to them in two
        |  %%% ways: &lt;ul&gt;&lt;li&gt;by returning a value&lt;/li&gt;&lt;li&gt;by executing an arbitrary
        |  %%% function&lt;/li&gt;&lt;/ul&gt;
        |  %%% This is done with {@link strict/4}, {@link strict/5}, {@link stub/4}, {@link stub/5}
        |  %%% &lt;/p&gt;
        |  %%%
        |  %%% &lt;p&gt;Before the code under test is executed, the mock must be told
        |  %%% that the programming phase is over by {@link replay/1}.&lt;/p&gt;
        |  %%%
        |  %%% &lt;p&gt;In the next phase the code under test is run, and might or
        |  %%% might not call the functions mocked.
        |  %%% The mock process checks that all functions programmed with
        |  %%% {@link strict/4}, {@link strict/5} are called in the
        |  %%% correct order, with the expected arguments and reacts in the way
        |  %%% defined during the programming phase. If a mocked function is called
        |  %%% although another function was expected, or if an expected function
        |  %%% was called with different arguments, the mock process dies and
        |  %%% prints a comprehensive error message before failing the test.&lt;/p&gt;
        |  %%%
        |  %%% &lt;p&gt;At the end of a unit test {@link await_expectations/1} is called to
        |  %%% await all invocations defined during the programming phase.&lt;/p&gt;
        |  %%%
        |  %%% &lt;p&gt;An alternative to {@link await_expectations/1} is {@link verify/1}. It is
        |  %%% called to check for missing invocations at the end of the programming phase,
        |  %%% if any expected invocations are missing at verify will throw an exception.&lt;/p&gt;
        |  %%%
        |  %%% &lt;p&gt;When the mock process exits it tries hard to remove all modules, that
        |  %%% were dynamically created and loaded during the programming phase.&lt;/p&gt;
        |  %%%
        |  %%% NOTE: This library works by purging the modules mocked and replacing
        |  %%% them with dynamically created and compiled code, so be careful what
        |  %%% you mock, i.e. it brings chaos to mock modules from kernel. This also
        |  %%% implies, that tests that mock the same modules must be run sequentially.
        |  %%%
        |  %%% Apart from that, it is very advisable to &lt;b&gt;only mock owned modules&lt;/b&gt;
        |  %%% anyway.
        |  %%%
        |  %%% @end
        |  %%%-----------------------------------------------------------------------------
        |  %%% Copyright (c) 2011,2012 Sven Heyll
        |  %%%
        |  %%% Permission is hereby granted, free of charge, to any person obtaining a copy
        |  %%% of this software and associated documentation files (the "Software"), to deal
        |  %%% in the Software without restriction, including without limitation the rights
        |  %%% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        |  %%% copies of the Software, and to permit persons to whom the Software is
        |  %%% furnished to do so, subject to the following conditions:
        |  %%%
        |  %%% The above copyright notice and this permission notice shall be included in
        |  %%% all copies or substantial portions of the Software.
        |  %%%
        |  %%% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        |  %%% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        |  %%% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        |  %%% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        |  %%% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        |  %%% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        |  %%% THE SOFTWARE.
        |  %%%
        |  %%%-----------------------------------------------------------------------------
        |  
        |  -module(em).
        |  
        |  -behaviour(gen_fsm).
        |  
        |  %% public API ---
        |  -export([new/0,
        |           strict/4,
        |           strict/5,
        |           stub/4,
        |           stub/5,
        |           replay/1,
        |           await/2,
        |           await_expectations/1,
        |           verify/1,
        |           any/0,
        |           zelf/0,
        |  	 nothing/2,
        |           lock/2]).
        |  
        |  %% gen_fsm callbacks ---
        |  -export([programming/3,
        |           replaying/2,
        |           replaying/3,
        |           no_expectations/3,
        |           terminate/3,
        |           init/1,
        |           code_change/4,
        |           handle_event/3,
        |           handle_info/3,
        |           handle_sync_event/4]).
        |  
        |  %% !!!NEVER CALL THIS FUNCTION!!! ---
        |  -export([invoke/4]).
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %% next invokation must happen in this time, orelse ... BOOM!!!111oneoneeleventy
        |  -define(INVOKATION_TIMEOUT, 4020).
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%%% important types
        |  %%
        |  
        |  %%------------------------------------------------------------------------------
        |  %% The type that defines the argument list passed to strict() or stub().
        |  %% Each list element is either a value that will be matched to the actual value
        |  %% of the parameter at that position, or a predicate function which will be
        |  %% applied to the actual argument.
        |  %%------------------------------------------------------------------------------
        |  -type args() :: [ fun((any()) -&gt;
        |                               true | false)
        |                       | term()].
        |  
        |  %%------------------------------------------------------------------------------
        |  %% The type that defines the response to a mocked function call. A response is
        |  %% either that a value is returned, or the application of a function to the
        |  %% actual arguments.
        |  %%------------------------------------------------------------------------------
        |  -type answer() :: {function, fun(([any()]) -&gt; any())}
        |                    | {return, any()} .
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%%% API
        |  %%
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Spawns a linked mock process and returns it's pid. This is usually the first
        |  %% thing to do in each unit test. The resulting pid is used in the other
        |  %% functions below. NOTE: only a single mock proccess is required for a single
        |  %% unit test case. One mock process can mock an arbitrary number of different
        |  %% modules.
        |  %% When the mock process dies, all uploaded modules are purged from the code
        |  %% server, and all cover compiled modules are restored.
        |  %% When the process that started the mock exits, the mock automatically cleans
        |  %% up and exits.
        |  %% After new() the mock is in 'programming' state.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec new() -&gt;
        |                   pid().
        |  new() -&gt;
    22..|      {ok, Pid} = gen_fsm:start_link(?MODULE, [erlang:self()], []),
    22..|      Pid.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Adds an expectation during the programming phase for a specific functiion
        |  %% invokation.
        |  %% &lt;p&gt;All expectations defined by 'strict' define an order in which the
        |  %% application must call the mocked functions, hence the name 'strict' as oposed
        |  %% to 'stub' (see below).&lt;/p&gt;
        |  %% &lt;p&gt;The parameters are:
        |  %% &lt;ul&gt;
        |  %% &lt;li&gt;&lt;code&gt;M&lt;/code&gt; the mock pid, returned by {@link new/0}&lt;/li&gt;
        |  %% &lt;li&gt;&lt;code&gt;Mod&lt;/code&gt; the module of the function to mock&lt;/li&gt;
        |  %% &lt;li&gt;&lt;code&gt;Fun&lt;/code&gt; the name of the function to mock&lt;/li&gt;
        |  %% &lt;li&gt;&lt;code&gt;Args&lt;/code&gt; a list of expected arguments.
        |  %% Each list element is either a value that will be matched to the actual value
        |  %% of the parameter at that position, or a predicate function which will be
        |  %% applied to the actual argument.&lt;/li&gt;
        |  %% &lt;/ul&gt;&lt;/p&gt;
        |  %% &lt;p&gt;This function returns a term that identifies this expectations so that the
        |  %% code under test can call {@link await/2} to block until this expectation is
        |  %% fullfilled.&lt;/p&gt;
        |  %% &lt;p&gt;
        |  %% The return value, that the application will get when calling the mocked
        |  %% function in the replay phase is simply the atom &lt;code&gt;ok&lt;/code&gt;. This
        |  %% differentiates this function from {@link strict/5}, which allows the
        |  %% definition of a custom response function or a custom return value.  &lt;/p&gt;
        |  %% NOTE: This function may only be called between &lt;code&gt;new/0&lt;/code&gt; and {@link
        |  %% replay/1} - that is during the programming phase.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec strict(pid(), atom(), atom(), args()) -&gt;
        |                      reference().
        |  strict(M, Mod, Fun, Args)
        |    when is_pid(M), is_atom(Mod), is_atom(Fun), is_list(Args) -&gt;
    17..|      strict(M, Mod, Fun, Args, {return, ok}).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% This function behaves like {@link strict/4}
        |  %% and additionally accepts a return value or an answer function. That parameter
        |  %% &lt;code&gt;Answer&lt;/code&gt; may be:
        |  %% &lt;ul&gt;
        |  %% &lt;li&gt;&lt;code&gt;{return, SomeValue}&lt;/code&gt; This causes the mocked function invocation to
        |  %% return the specified value.&lt;/li&gt;
        |  %% &lt;li&gt;&lt;code&gt;{function, fun(([Arg1, ... , ArgN]) -&gt; SomeValue)}&lt;/code&gt; This defines
        |  %% a function to be called when the mocked invokation happens.
        |  %% That function is applied to all captured actual arguments.  For convenience these
        |  %% are passed as a list, so the user can simply write &lt;code&gt;fun(_) -&gt; ...&lt;/code&gt;
        |  %% when the actual values are not needed.
        |  %% The function will be executed by the process that calls the mocked function, not
        |  %% by the mock process. Hence the function may access &lt;code&gt;self()&lt;/code&gt; and may
        |  %% throw an exception, which will then correctly appear in the process under test,
        |  %% allowing unit testing of exception handling.
        |  %% Otherwise the value returned by the function is passed through as the value
        |  %% returned from the invocation.
        |  %% &lt;/li&gt;
        |  %% &lt;/ul&gt;
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec strict(pid(), atom(), atom(), args(), answer()) -&gt;
        |                      reference().
        |  strict(M, Mod, Fun, Args, Answer = {return, _})
        |    when is_pid(M), is_atom(Mod), is_atom(Fun), is_list(Args) -&gt;
    19..|      gen_fsm:sync_send_event(M, {strict, Mod, Fun, Args, Answer});
        |  strict(M, Mod, Fun, Args, Answer = {function, _})
        |    when is_pid(M), is_atom(Mod), is_atom(Fun), is_list(Args) -&gt;
     4..|      gen_fsm:sync_send_event(M, {strict, Mod, Fun, Args, Answer}).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Defines a what happens when a function is called whithout recording any
        |  %% expectations. The invocations defined by this function may happen in any order
        |  %% any number of times. The way, the invocation is defined is analog to
        |  %% @see strict/4. &lt;code&gt;strict/4&lt;/code&gt;
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec stub(pid(), atom(), atom(), args()) -&gt;
        |                    ok.
        |  stub(M, Mod, Fun, Args)
        |    when is_pid(M), is_atom(Mod), is_atom(Fun), is_list(Args) -&gt;
     1..|      stub(M, Mod, Fun, Args, {return, ok}).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% This is similar &lt;code&gt;stub/4&lt;/code&gt; except that it, like
        |  %% &lt;code&gt;strict/5&lt;/code&gt; allows the definition of a return value
        |  %% or an answer function.
        |  %% @see stub/4. &lt;code&gt;stub/4&lt;/code&gt;
        |  %% @see strict/5. &lt;code&gt;strict/5&lt;/code&gt;
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec stub(pid(), atom(), atom(), args(), answer()) -&gt;
        |                    ok.
        |  stub(M, Mod, Fun, Args, Answer = {return, _})
        |    when is_pid(M), is_atom(Mod), is_atom(Fun), is_list(Args) -&gt;
     4..|      ok = gen_fsm:sync_send_event(M, {stub, Mod, Fun, Args, Answer});
        |  stub(M, Mod, Fun, Args, Answer = {function, _})
        |    when is_pid(M), is_atom(Mod), is_atom(Fun), is_list(Args) -&gt;
     2..|      ok = gen_fsm:sync_send_event(M, {stub, Mod, Fun, Args, Answer}).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% This is used to express the expectation that no function of a certain module
        |  %% is called. This will cause each function call on a module to throw an 'undef'
        |  %% exception.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec nothing(pid(), atom()) -&gt;
        |  		     ok.
        |  nothing(M, Mod) when is_pid(M), is_atom(Mod) -&gt;
     1..|     ok = gen_fsm:sync_send_event(M, {nothing, Mod}).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% The function will block until all modules in the list are not
        |  %% mocked by another erlymock process.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec lock(pid(), [atom()]) -&gt;
        |  		     ok.
        |  lock(M, Mods) when is_pid(M), is_list(Mods) -&gt;
     1..|     ok = em_module_locker:lock(M, Mods).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Finishes the programming phase and switches to the replay phase where the
        |  %% actual code under test may run and invoke the functions mocked. This may
        |  %% be called only once, and only in the programming phase. This also loads
        |  %% (or replaces) the modules of the functions mocked.
        |  %% In the replay phase the code under test may call all mocked functions.
        |  %% If the application calls a mocked function with invalid arguments, or
        |  %% if the application calls a function not expected on a mocked module, the mock
        |  %% process dies and - if used in a typical edoc test suite - fails the test.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec replay(M :: term()) -&gt; ok.
        |  replay(M) -&gt;
    22..|      ok = gen_fsm:sync_send_event(M, replay).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Block until a specific invokation defined via {@link strict/4} during the
        |  %% programming phase was made. The handle for the specific invokation is the
        |  %% value returned by {@link strict/4}. The return value contains the actual
        |  %% parameters of the invokation and the pid of the process that does the
        |  %% invokation is also returned. In case the invokation has already happed, the
        |  %% function returns immediately. If the handle is not valid, an error is
        |  %% returned.
        |  %% @end
        |  %% ------------------------------------------------------------------------------
        |  -spec await(M :: term(), Handle :: reference()) -&gt;
        |                     {success,
        |                      InvPid :: pid(),
        |                      Args :: [term()]} |
        |                     {error, invalid_handle}.
        |  await(M, Handle) -&gt;
     3..|      gen_fsm:sync_send_all_state_event(M, {await, Handle}, 5000).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Wait until all invokations defined during the programming phase were made.
        |  %% After this functions returns, the mock can be expected to exit and clean up
        |  %% all modules installed.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec await_expectations(M :: term()) -&gt; ok.
        |  await_expectations(M) -&gt;
     2..|      ok = gen_fsm:sync_send_all_state_event(M, await_expectations, 5000).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Finishes the replay phase. If the code under test did not cause all expected
        |  %% invokations defined by {@link strict/4} or {@link strict/5}, the
        |  %% call will fail with &lt;code&gt;badmatch&lt;/code&gt; with a comprehensive error message.
        |  %% Otherwise the mock process exits normally, returning &lt;code&gt;ok&lt;/code&gt;.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec verify(M :: term()) -&gt; ok.
        |  verify(M) -&gt;
    15..|      ok = gen_fsm:sync_send_event(M, verify).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Utility function that can be used as a match function in an argument list
        |  %% to match any value.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec any() -&gt;
        |                   fun((any()) -&gt;
        |                      true).
        |  any() -&gt;
     1..|      fun(_) -&gt;
     4..|              true
        |      end.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @doc
        |  %% Utility function that can be used as a match function in an
        |  %% argument list to match &lt;code&gt;self()&lt;/code&gt;, e.g. when it matches the pid of the
        |  %% process, that calls the funtion during the replay phase.
        |  %% @end
        |  %%------------------------------------------------------------------------------
        |  -spec zelf() -&gt;
        |                    atom().
        |  zelf() -&gt;
     1..|      '$$em zelf$$'.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%%% internal state
        |  %%
        |  
        |  -record(expectation,
        |          {id :: reference(),
        |           m :: atom(),
        |           f :: atom(),
        |           a :: args(),
        |           answer :: answer(),
        |           listeners :: [GenFsmFrom :: term()]}).
        |  
        |  -record(state, {
        |            test_proc :: pid(),
        |            inv_to_ref :: reference(),
        |            strict :: [#expectation{}],
        |            strict_log :: [{strict_log,
        |                            ERef :: reference(),
        |                            IPid :: pid(),
        |                            Args :: [term()]}],
        |            stub  :: [#expectation{}],
        |  	  blacklist :: [atom()],
        |            mocked_modules :: [{atom(), {just, term()}|nothing}],
        |            await_invokations_reply :: nothing | {just, term()}
        |           }).
        |  
        |  -type statedata() :: #state{}.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%%% gen_fsm callbacks
        |  %%i
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec init([TestProc :: term()]) -&gt;
        |                    {ok, atom(), StateData :: statedata()}.
        |  init([TestProc]) -&gt;
    22..|      process_flag(sensitive, true),
    22..|      erlang:trace(self(), false, [all]),
    22..|      {ok,
        |       programming,
        |       #state{
        |          test_proc = TestProc,
        |          strict = [],
        |          strict_log = [],
        |          stub = [],
        |          blacklist = [],
        |          mocked_modules = [],
        |          await_invokations_reply = nothing}}.
        |  
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec programming(Event :: term(), From :: term(), State :: statedata()) -&gt;
        |                           {reply, Reply :: term(), NextState :: atom(),
        |                            NewStateData :: statedata()}.
        |  programming({strict, Mod, Fun, Args, Answer},
        |              _From,
        |              State = #state{strict = Strict}) -&gt;
    23..|      InvRef = make_ref(),
    23..|      {reply,
        |       InvRef,
        |       programming,
        |       State#state{
        |         strict = [#expectation{id = InvRef,
        |                                m = Mod,
        |                                f = Fun,
        |                                a = Args,
        |                                answer = Answer,
        |                                listeners = []}
        |                   |Strict]}};
        |  
        |  programming({stub, Mod, Fun, Args, Answer},
        |              _From,
        |              State = #state{stub = Stub}) -&gt;
     6..|      {reply,
        |       ok,
        |       programming,
        |       State#state{
        |         stub = [#expectation{m = Mod, f = Fun, a = Args, answer = Answer}|Stub]}};
        |  
        |  programming({nothing, Mod},
        |              _From,
        |              State = #state{blacklist = BL}) -&gt;
     1..|      {reply,
        |       ok,
        |       programming,
        |       State#state{
        |         blacklist = [Mod | BL]}};
        |  
        |  programming(replay,
        |              _From,
        |              State = #state{strict = Strict}) -&gt;
    22..|      MMs = install_mock_modules(State),
    22..|      InvTORef = gen_fsm:start_timer(?INVOKATION_TIMEOUT, invokation_timeout),
    22..|      {reply,
        |       ok,
        |       case Strict of
     6..|           [] -&gt; no_expectations;
    16..|           _ -&gt; replaying
        |       end,
        |       State#state{
        |         inv_to_ref = InvTORef,
        |         strict = lists:reverse(Strict),
        |         mocked_modules = MMs}}.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private (goto-char 1)
        |  %%------------------------------------------------------------------------------
        |  -spec replaying(Event :: term(), StateData :: statedata()) -&gt;
        |                         {stop, Reason :: term(), NewStateData :: statedata()}.
        |  replaying({timeout, Ref, invokation_timeout},
        |            State = #state{inv_to_ref = Ref,
        |                           strict = Expectations}) -&gt;
     1..|      {stop,{invokation_timeout, {missing_invokations, Expectations}},State}.
        |  
        |  -spec replaying(Event :: term(), From :: term(), StateData :: statedata()) -&gt;
        |                         {reply, Reply :: term(), NextState :: atom(),
        |                          NewStateData :: statedata()} |
        |                         {stop, Reason :: term(), Reply :: term(),
        |                          NewStateData :: statedata()}.
        |  replaying(I = {invokation, Mod, Fun, Args, IPid},
        |            From,
        |            State = #state{
        |              await_invokations_reply = AwInvRepl,
        |              inv_to_ref = InvTORef,
        |              strict = [#expectation{
        |                           id     = ERef,
        |                           m      = Mod,
        |                           f      = Fun,
        |                           a      = EArgs,
        |                           answer = Answer,
        |                           listeners = Listeners}
        |                        |Rest]})
        |    when length(EArgs) == length(Args) -&gt;
    19..|      gen_fsm:cancel_timer(InvTORef),
    19..|      case check_args(Args, EArgs, IPid) of
        |          true -&gt;
    17..|              gen_fsm:reply(From, Answer),
    17..|              [gen_fsm:reply(Listener, {success, IPid, Args})
    17..|               || Listener &lt;- Listeners],
    17..|              NextState = case Rest of
    11..|                              [] -&gt; no_expectations;
        |                              _ -&gt;
     6..|                                  replaying
        |                          end,
    17..|              if NextState =:= replaying orelse AwInvRepl =:= nothing -&gt;
    16..|                      NextTimer = gen_fsm:start_timer(?INVOKATION_TIMEOUT,
        |                                                      invokation_timeout),
    16..|                      {next_state, NextState,
        |                       State#state{inv_to_ref = NextTimer,
        |                                   strict=Rest,
        |                                   strict_log =
        |                                       [{strict_log, ERef, IPid, Args}
        |                                        | State#state.strict_log]}};
        |                 true -&gt;
     1..|                      {just, AIR} = AwInvRepl,
     1..|                      gen_fsm:reply(AIR, ok),
     1..|                      {stop, normal, State}
        |              end;
        |          {error, Index, Expected, Actual} -&gt;
     2..|              Reason = {unexpected_function_parameter,
        |                        {error_in_parameter, Index},
        |                        {expected, Expected},
        |                        {actual, Actual},
        |                        I},
     2..|              {stop, Reason, Reason, State}
        |      end;
        |  
        |  replaying(I = {invokation, _M, _F, _A, _IPid},
        |            _From,
        |            State = #state{
        |              inv_to_ref = InvTORef,
        |  	    strict = [E|_]}) -&gt;
     2..|      gen_fsm:cancel_timer(InvTORef),
     2..|      case handle_stub_invokation(I, State#state.stub) of
        |  	{ok, Answer} -&gt;
     1..|  	    {reply, Answer, replaying,
        |               State#state{
        |                 inv_to_ref = gen_fsm:start_timer(?INVOKATION_TIMEOUT, invokation_timeout)
        |                }};
        |  
        |  	error -&gt;
     1..|  	    Reason = {unexpected_invokation, {actual, I}, {expected, E}},
     1..|  	    {stop, Reason, Reason, State}
        |      end;
        |  
        |  replaying(verify,
        |            _From,
        |            State = #state{inv_to_ref = InvTORef}) -&gt;
     1..|      gen_fsm:cancel_timer(InvTORef),
     1..|      Reason = {invokations_missing, State#state.strict},
     1..|      {stop, Reason, Reason, State}.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec no_expectations(Event :: term(), From :: term(),
        |                        StateData :: statedata()) -&gt;
        |                               {reply, Reply :: term(), NextState :: atom(),
        |                                NewStateData :: statedata()} |
        |                               {stop, Reason :: term(), Reply :: term(),
        |                                NewStateData :: statedata()}.
        |  no_expectations(I = {invokation, _M, _F, _A, _IPid}, _From, State = #state{inv_to_ref = InvTORef}) -&gt;
     9..|      gen_fsm:cancel_timer(InvTORef),
     9..|      case handle_stub_invokation(I, State#state.stub) of
        |          {ok, Answer} -&gt;
     8..|              {reply, Answer, no_expectations, State};
        |  
        |          error -&gt;
     1..|              Reason = {unexpected_invokation, {actual, I}},
     1..|              {stop, Reason, Reason, State}
        |      end;
        |  
        |  no_expectations(verify,
        |           _From,
        |           State) -&gt;
    14..|      {stop, normal, ok, State}.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec terminate(Reason :: term(), StateName :: atom(),
        |                  StateData :: statedata()) -&gt; no_return().
        |  terminate(Reason, _StateName, State = #state{test_proc = TestProc}) -&gt;
    22..|      unload_mock_modules(State),
    22..|      exit(TestProc, Reason).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec code_change(OldVsn :: term(), StateName :: atom(), State :: statedata(),
        |                    Extra :: term()) -&gt;
        |                           {ok, NextState :: atom(), NewStateData :: statedata()}.
        |  code_change(_OldVsn, StateName, State, _Extra) -&gt;
     1..|      {ok, StateName, State}.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec handle_sync_event(Event :: term(), From :: term(), StateName :: atom(),
        |                          StateData :: statedata()) -&gt;
        |                                 {stop, normal, ok, NewStateData :: statedata()}
        |                                     | {next_state, StateName :: atom(),
        |                                        NewStateData :: statedata()}.
        |  handle_sync_event({await, H}, From, StateName, State) -&gt;
     3..|      {next_state, StateName, add_invokation_listener(From, H, State)};
        |  handle_sync_event(await_expectations, _From, no_expectations, State) -&gt;
     1..|      {stop, normal, ok, State};
        |  handle_sync_event(await_expectations, From, StateName,
        |                    State =  #state{await_invokations_reply = nothing}) -&gt;
     1..|      {next_state, StateName, State#state{await_invokations_reply = {just, From}}};
        |  handle_sync_event(_Evt, _From, _StateName, State) -&gt;
     1..|      {stop, normal, ok, State}.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec handle_info(Info :: term(), StateName :: atom(),
        |                    StateData :: statedata()) -&gt;
        |                           {stop, normal, NewStateData :: statedata()}.
        |  handle_info(_Info, _StateName, State) -&gt;
     1..|      {stop, normal, State}.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec handle_event(Msg :: term(), StateName :: atom(),
        |                     StateData :: statedata()) -&gt;
        |                            {stop, normal, NewStateData :: statedata()}.
        |  handle_event(_Msg, _StateName, State) -&gt;
     1..|      {stop, normal, State}.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%%% api for generated mock code
        |  %%
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec invoke(M :: term(), Mod :: term(), Fun :: fun(), Args :: list()) -&gt;
        |                      {Value :: term()}.
        |  invoke(M, Mod, Fun, Args) -&gt;
    30..|      case gen_fsm:sync_send_event(M, {invokation, Mod, Fun, Args, self()}) of
        |          {return, Value} -&gt;
    20..|              Value;
        |          {function, F} -&gt;
     6..|              F(Args)
        |      end.
        |  
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%%% internal functions
        |  %%
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  unload_mock_modules(#state{mocked_modules = MMs}) -&gt;
    22..|      [begin
    24..|     code:purge(Mod),
    24..|  	 code:delete(Mod),
    24..|  	 code:purge(Mod),
    24..|           case MaybeBin of
        |                nothing -&gt;
    24..|                   ignore;
        |               {just, {Mod, CoverCompiledBinary}} -&gt;
<font color=red>     0..|                   code:load_binary(Mod, cover_compiled, CoverCompiledBinary)</font>
        |           end
        |       end
    22..|       || {Mod, MaybeBin} &lt;- MMs].
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  install_mock_modules(#state{strict = ExpectationsStrict,
        |                              stub = ExpectationsStub,
        |  			    blacklist = BlackList}) -&gt;
    22..|      Expectations = ExpectationsStub ++ ExpectationsStrict,
    22..|      ModulesToMock = lists:usort([M || #expectation{m = M} &lt;- Expectations] ++ BlackList),
    22..|      em_module_locker:lock(erlang:self(), ModulesToMock),
    22..|      [install_mock_module(M, Expectations) || M &lt;- ModulesToMock].
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  install_mock_module(Mod, Expectations) -&gt;
    24..|      MaybeBin = get_cover_compiled_binary(Mod),
    24..|      ModHeaderSyn = [erl_syntax:attribute(erl_syntax:atom(module),
        |  					 [erl_syntax:atom(Mod)]),
        |                      erl_syntax:attribute(erl_syntax:atom(compile),
        |                                           [erl_syntax:list(
        |                                              [erl_syntax:atom(export_all)])])],
    24..|      Funs = lists:usort(
    29..|               [{F, length(A)} || #expectation{m = M, f = F, a = A} &lt;- Expectations,
    42..|                                  M == Mod]),
    24..|      FunFormsSyn = [mock_fun_syn(Mod, F, A) || {F, A} &lt;- Funs],
        |  
    24..|      {ok, Mod, Code} =
    76..|          compile:forms([erl_syntax:revert(F)
    24..|                         || F &lt;- ModHeaderSyn ++ FunFormsSyn]),
        |  
    24..|      code:purge(Mod),
    24..|      code:delete(Mod),
    24..|      code:purge(Mod),
    24..|      {module, _} = load_module(Mod, Code),
    24..|      {Mod, MaybeBin}.
        |  
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  mock_fun_syn(Mod, F, Args) -&gt;
    28..|      ArgsSyn = var_list_syn(Args),
    28..|      FunSyn = erl_syntax:atom(F),
    28..|      erl_syntax:function(
        |         FunSyn,
        |         [erl_syntax:clause(ArgsSyn,
        |                            none,
        |                            body_syn(Mod, FunSyn, ArgsSyn))]).
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  var_list_syn(Args) -&gt;
    28..|      [erl_syntax:variable(list_to_atom("Arg_" ++ integer_to_list(I)))
    28..|       || I &lt;- lists:seq(0, Args - 1)].
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  body_syn(Mod, FunSyn, ArgsSyn) -&gt;
    28..|      SelfStr = pid_to_list(erlang:self()),
    28..|      SelfSyn = erl_syntax:application(
        |                  erl_syntax:atom(erlang),
        |                  erl_syntax:atom(list_to_pid),
        |                  [erl_syntax:string(SelfStr)]),
    28..|      [erl_syntax:application(
        |         erl_syntax:atom(?MODULE),
        |         erl_syntax:atom(invoke),
        |         [SelfSyn,
        |          erl_syntax:atom(Mod),
        |          FunSyn,
        |          erl_syntax:list(ArgsSyn)])].
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  check_args(Args, ArgSpecs, InvokationPid) -&gt;
    28..|      try
    28..|          [begin
    48..|               if
        |                   is_function(E) -&gt;
     7..|                       case E(A) of
        |                           true -&gt;
     6..|                               ok;
        |                           _ -&gt;
     1..|                               throw({error, I, E, A})
        |                       end;
        |                   true -&gt;
    41..|                       case E of
        |  
        |                           '$$em zelf$$' -&gt;
     1..|                               if A =/= InvokationPid -&gt;
<font color=red>     0..|                                       throw({error, I, E, A});</font>
        |                                  true -&gt;
     1..|                                       ok
        |                               end;
        |  
        |                           A -&gt;
    39..|                               ok;
        |  
        |                           _Otherwise -&gt;
     1..|                               throw({error, I, E, A})
        |                       end
        |               end
        |           end
    28..|           || {I, A, E} &lt;- lists:zip3(lists:seq(1, length(Args)),
        |                                      Args,
        |                                      ArgSpecs)] of
        |          _ -&gt;
    26..|              true
        |      catch
        |          _:E -&gt;
     2..|              E
        |      end.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  handle_stub_invokation({invokation, Mod, Fun, Args, IPid}, Stubs) -&gt;
    11..|      case [MatchingStub
    11..|            || MatchingStub = #expectation {m = M, f = F, a = A} &lt;- Stubs,
    17..|               M == Mod, F == Fun, length(Args) == length(A),
     9..|               check_args(Args, A, IPid) == true] of
        |  
        |          [#expectation{answer = Answer}|_] -&gt;
     9..|              {ok, Answer};
        |  
        |          _ -&gt;
     2..|              error
        |      end.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  -spec get_cover_compiled_binary(atom()) -&gt;
        |                                         {just, term()} | nothing.
        |  get_cover_compiled_binary(Mod) -&gt;
    24..|      case code:which(Mod) of
        |          cover_compiled -&gt;
<font color=red>     0..|              case ets:info(cover_binary_code_table) of</font>
        |                  undefined -&gt;
<font color=red>     0..|                      nothing;</font>
        |                  _ -&gt;
<font color=red>     0..|                      case ets:lookup(cover_binary_code_table, Mod) of</font>
        |                          [Binary] -&gt;
<font color=red>     0..|                              {just, Binary};</font>
        |                          _ -&gt;
<font color=red>     0..|                              nothing</font>
        |                      end
        |              end;
        |          _ -&gt;
    24..|              nothing
        |      end.
        |  
        |  %%------------------------------------------------------------------------------
        |  %% @private
        |  %%------------------------------------------------------------------------------
        |  add_invokation_listener(From, Ref, State = #state{strict=Strict,
        |                                                    strict_log = StrictSucc}) -&gt;
        |      %% if the invokation does not exist, check the strict_history
     3..|      case lists:keyfind(Ref, 2, Strict) of
        |          false -&gt;
     2..|              case lists:keyfind(Ref, 2, StrictSucc) of
        |                  false -&gt;
     1..|                      gen_fsm:reply(From, {error, invalid_handle});
        |  
        |                  {strict_log, _ERef, IPid, Args} -&gt;
     1..|                      gen_fsm:reply(From, {success, IPid, Args})
        |              end,
     2..|              State;
        |  
        |          E = #expectation{listeners = Ls} -&gt;
     1..|              NewE = E#expectation{listeners = [From|Ls]},
     1..|              NewStrict = lists:keyreplace(Ref, 2, Strict, NewE),
     1..|              State#state{strict = NewStrict}
        |      end.
</pre>
</body>
</html>
